package com.example.scanner.service

import com.example.scanner.model.*
import com.example.scanner.config.ThymeleafTestConfiguration
import org.springframework.beans.factory.annotation.Autowired
import org.springframework.boot.test.context.SpringBootTest
import org.springframework.test.context.TestPropertySource
import org.springframework.test.context.ContextConfiguration
import org.thymeleaf.TemplateEngine
import spock.lang.Specification
import spock.lang.TempDir

import java.nio.file.Path
import java.nio.file.Paths
import java.util.regex.Pattern

/**
 * Tests that validate the actual HTML output structure, styling, and visual elements
 * generated by the templating system.
 */
@SpringBootTest
@ContextConfiguration(classes = [ThymeleafTestConfiguration])
@TestPropertySource(locations = "classpath:application-test.properties")
class HtmlOutputValidationSpec extends Specification {

    @Autowired
    TemplateEngine templateEngine

    ConcurrencyReportGenerator generator
    ThymeleafTemplateProcessor templateProcessor

    @TempDir
    Path tempDir

    def setup() {
        templateProcessor = new ThymeleafTemplateProcessor(templateEngine)
        generator = new ConcurrencyReportGenerator(templateProcessor)
    }

    def "should generate HTML with proper visual styling and CSS classes"() {
        given: "analysis results with various issue severities"
        def results = createStyledTestResults()
        def outputPath = tempDir.resolve("styled-report.html").toString()

        when: "generating HTML report"
        generator.generateHtmlReport(results, outputPath)

        then: "HTML should contain proper CSS classes and styling"
        def htmlContent = tempDir.resolve("styled-report.html").toFile().text

        // Should contain CSS classes for different severities
        htmlContent.contains("severity-critical") || htmlContent.contains("critical")
        htmlContent.contains("severity-high") || htmlContent.contains("high")
        htmlContent.contains("severity-medium") || htmlContent.contains("medium")

        and: "should have proper container structure"
        htmlContent.contains("class=\"container\"") || htmlContent.contains("container")
        htmlContent.contains("class=\"header\"") || htmlContent.contains("header")
        htmlContent.contains("class=\"summary\"") || htmlContent.contains("summary")

        and: "should include responsive design CSS"
        htmlContent.contains("max-width")
        htmlContent.contains("grid-template-columns") || htmlContent.contains("flex")
        htmlContent.contains("@media") || htmlContent.contains("responsive")
    }

    def "should generate HTML with proper table structure for issues and recommendations"() {
        given: "comprehensive analysis results"
        def results = createTableTestResults()
        def outputPath = tempDir.resolve("table-report.html").toString()

        when: "generating HTML report"
        generator.generateHtmlReport(results, outputPath)

        then: "HTML should contain properly structured tables"
        def htmlContent = tempDir.resolve("table-report.html").toFile().text

        // Should contain table elements
        htmlContent.contains("<table")
        htmlContent.contains("<thead")
        htmlContent.contains("<tbody")
        htmlContent.contains("<tr")
        htmlContent.contains("<th")
        htmlContent.contains("<td")

        and: "should have proper table headers"
        htmlContent.contains("Class Name") || htmlContent.contains("File")
        htmlContent.contains("Issue Type") || htmlContent.contains("Type")
        htmlContent.contains("Severity")
        htmlContent.contains("Description")

        and: "should contain data rows"
        htmlContent.contains("UserService")
        htmlContent.contains("RACE_CONDITION")
        htmlContent.contains("HIGH")
    }

    def "should generate HTML with proper navigation and sections"() {
        given: "multi-section analysis results"
        def results = createNavigationTestResults()
        def outputPath = tempDir.resolve("navigation-report.html").toString()

        when: "generating HTML report"
        generator.generateHtmlReport(results, outputPath)

        then: "HTML should contain proper sections and navigation"
        def htmlContent = tempDir.resolve("navigation-report.html").toFile().text

        // Should contain main sections
        htmlContent.contains("Executive Summary") || htmlContent.contains("summary")
        htmlContent.contains("Class-Level Analysis") || htmlContent.contains("classes")
        htmlContent.contains("Detailed Issues") || htmlContent.contains("issues")
        htmlContent.contains("Recommendations") || htmlContent.contains("recommendations")

        and: "should have proper section structure"
        htmlContent.contains("<section") || htmlContent.contains("class=\"section\"")
        htmlContent.contains("<h1") || htmlContent.contains("<h2")
        htmlContent.contains("<h3")
    }

    def "should generate HTML with proper color coding for different severities"() {
        given: "results with all severity levels"
        def results = createSeverityTestResults()
        def outputPath = tempDir.resolve("severity-colors-report.html").toString()

        when: "generating HTML report"
        generator.generateHtmlReport(results, outputPath)

        then: "HTML should contain color-coded elements"
        def htmlContent = tempDir.resolve("severity-colors-report.html").toFile().text

        // Should contain CSS with color definitions
        htmlContent.contains("color:") || htmlContent.contains("background-color:")
        htmlContent.contains("#") // Hex color codes

        and: "should reference severity-specific styling"
        htmlContent.contains("CRITICAL")
        htmlContent.contains("HIGH")
        htmlContent.contains("MEDIUM")
        htmlContent.contains("LOW")
    }

    def "should generate HTML with proper statistics visualization"() {
        given: "results with varied statistics"
        def results = createStatisticsTestResults()
        def outputPath = tempDir.resolve("statistics-report.html").toString()

        when: "generating HTML report"
        generator.generateHtmlReport(results, outputPath)

        then: "HTML should contain statistics display elements"
        def htmlContent = tempDir.resolve("statistics-report.html").toFile().text

        // Should contain statistics display
        htmlContent.contains("Files Analyzed:")
        htmlContent.contains("Thread-Safe Files:")
        htmlContent.contains("Files with Issues:")
        htmlContent.contains("Total Issues Found:")

        and: "should have proper number formatting"
        htmlContent.contains("10") // Total files
        htmlContent.contains("7")  // Thread-safe files
        htmlContent.contains("3")  // Files with issues
        htmlContent.contains("15") // Total issues

        and: "should contain percentage calculations"
        htmlContent.contains("%") || htmlContent.contains("percent")
    }

    def "should generate HTML that passes basic accessibility checks"() {
        given: "standard analysis results"
        def results = createAccessibilityTestResults()
        def outputPath = tempDir.resolve("accessibility-report.html").toString()

        when: "generating HTML report"
        generator.generateHtmlReport(results, outputPath)

        then: "HTML should meet basic accessibility requirements"
        def htmlContent = tempDir.resolve("accessibility-report.html").toFile().text

        // Should have proper meta tags
        htmlContent.contains('lang="en"')
        htmlContent.contains('<meta charset="UTF-8">')
        htmlContent.contains('<meta name="viewport"')

        and: "should have proper heading hierarchy"
        htmlContent.contains("<h1")
        htmlContent.contains("<h2")
        
        and: "should have proper table structure if tables exist"
        if (htmlContent.contains("<table")) {
            assert htmlContent.contains("<thead")
            assert htmlContent.contains("<tbody")
            assert htmlContent.contains("<th")
        }

        and: "should have proper semantic structure"
        htmlContent.contains("<title>")
        htmlContent.contains("</title>")
    }

    def "should generate HTML with proper mobile responsiveness"() {
        given: "comprehensive analysis results"
        def results = createResponsiveTestResults()
        def outputPath = tempDir.resolve("responsive-report.html").toString()

        when: "generating HTML report"
        generator.generateHtmlReport(results, outputPath)

        then: "HTML should contain responsive design elements"
        def htmlContent = tempDir.resolve("responsive-report.html").toFile().text

        // Should contain viewport meta tag
        htmlContent.contains('name="viewport"')
        htmlContent.contains('width=device-width')

        and: "should contain responsive CSS"
        htmlContent.contains("max-width") || htmlContent.contains("min-width")
        htmlContent.contains("@media") || htmlContent.contains("responsive")

        and: "should use flexible layouts"
        htmlContent.contains("grid") || htmlContent.contains("flex") || htmlContent.contains("auto-fit")
    }

    def "should validate HTML output for proper encoding and special characters"() {
        given: "results with special characters and Unicode"
        def results = createEncodingTestResults()
        def outputPath = tempDir.resolve("encoding-report.html").toString()

        when: "generating HTML report"
        generator.generateHtmlReport(results, outputPath)

        then: "HTML should properly handle encoding"
        def htmlContent = tempDir.resolve("encoding-report.html").toFile().text

        // Should have proper encoding declaration
        htmlContent.contains('charset="UTF-8"')

        and: "should properly escape HTML entities"
        htmlContent.contains("&lt;") // < should be escaped
        htmlContent.contains("&gt;") // > should be escaped
        htmlContent.contains("&amp;") // & should be escaped
        htmlContent.contains("&quot;") // " should be escaped

        and: "should not contain unescaped special characters in content"
        // Raw angle brackets should not appear in issue descriptions
        def contentWithoutTags = htmlContent.replaceAll(/<[^>]+>/, "")
        !contentWithoutTags.contains("<dangerous>")
        !contentWithoutTags.contains("</dangerous>")
    }

    // Helper Methods for Creating Test Data

    private List<AnalysisResult> createStyledTestResults() {
        def criticalIssue = createConcurrencyIssue("DEADLOCK", IssueSeverity.CRITICAL, "Critical deadlock issue")
        def highIssue = createConcurrencyIssue("RACE_CONDITION", IssueSeverity.HIGH, "High priority race condition")
        def mediumIssue = createConcurrencyIssue("UNSAFE_COLLECTION", IssueSeverity.MEDIUM, "Medium priority collection issue")

        return [
            createAnalysisResultWithIssues("CriticalClass.java", false, [criticalIssue], []),
            createAnalysisResultWithIssues("HighIssueClass.java", false, [highIssue], []),
            createAnalysisResultWithIssues("MediumIssueClass.java", false, [mediumIssue], [])
        ]
    }

    private List<AnalysisResult> createTableTestResults() {
        def issue1 = createConcurrencyIssue("RACE_CONDITION", IssueSeverity.HIGH, "Data race in shared state")
        def issue2 = createConcurrencyIssue("SYNC_ISSUE", IssueSeverity.MEDIUM, "Synchronization problem")
        def rec1 = createDetailedRecommendation("Fix synchronization", RecommendationPriority.HIGH, RecommendationEffort.MEDIUM)

        return [
            createAnalysisResultWithIssues("UserService.java", false, [issue1, issue2], [rec1])
        ]
    }

    private List<AnalysisResult> createNavigationTestResults() {
        def issues = [
            createConcurrencyIssue("ISSUE_1", IssueSeverity.HIGH, "First issue"),
            createConcurrencyIssue("ISSUE_2", IssueSeverity.MEDIUM, "Second issue")
        ]
        def recommendations = [
            createDetailedRecommendation("First recommendation", RecommendationPriority.HIGH, RecommendationEffort.SMALL),
            createDetailedRecommendation("Second recommendation", RecommendationPriority.MEDIUM, RecommendationEffort.LARGE)
        ]

        return [
            createAnalysisResultWithIssues("ClassOne.java", false, [issues[0]], [recommendations[0]]),
            createAnalysisResultWithIssues("ClassTwo.java", false, [issues[1]], [recommendations[1]])
        ]
    }

    private List<AnalysisResult> createSeverityTestResults() {
        return [
            createAnalysisResultWithIssues("Critical.java", false, 
                [createConcurrencyIssue("CRITICAL_ISSUE", IssueSeverity.CRITICAL, "Critical problem")], []),
            createAnalysisResultWithIssues("High.java", false,
                [createConcurrencyIssue("HIGH_ISSUE", IssueSeverity.HIGH, "High problem")], []),
            createAnalysisResultWithIssues("Medium.java", false,
                [createConcurrencyIssue("MEDIUM_ISSUE", IssueSeverity.MEDIUM, "Medium problem")], []),
            createAnalysisResultWithIssues("Low.java", false,
                [createConcurrencyIssue("LOW_ISSUE", IssueSeverity.LOW, "Low problem")], [])
        ]
    }

    private List<AnalysisResult> createStatisticsTestResults() {
        def results = []
        
        // Create 10 files: 7 thread-safe, 3 with issues
        for (int i = 1; i <= 7; i++) {
            results.add(createAnalysisResultWithIssues("ThreadSafe${i}.java", true, [], []))
        }
        
        for (int i = 1; i <= 3; i++) {
            def issues = (1..5).collect { j ->
                createConcurrencyIssue("ISSUE_${i}_${j}", IssueSeverity.HIGH, "Issue ${j} in file ${i}")
            }
            results.add(createAnalysisResultWithIssues("WithIssues${i}.java", false, issues, []))
        }
        
        return results
    }

    private List<AnalysisResult> createAccessibilityTestResults() {
        def issue = createConcurrencyIssue("ACCESSIBILITY_TEST", IssueSeverity.MEDIUM, "Test issue for accessibility")
        def rec = createDetailedRecommendation("Test recommendation", RecommendationPriority.MEDIUM, RecommendationEffort.SMALL)
        
        return [createAnalysisResultWithIssues("AccessibilityTest.java", false, [issue], [rec])]
    }

    private List<AnalysisResult> createResponsiveTestResults() {
        def issues = (1..5).collect { i ->
            createConcurrencyIssue("RESPONSIVE_ISSUE_${i}", IssueSeverity.MEDIUM, "Issue ${i} for responsive test")
        }
        def recommendations = (1..3).collect { i ->
            createDetailedRecommendation("Recommendation ${i}", RecommendationPriority.MEDIUM, RecommendationEffort.MEDIUM)
        }
        
        return [createAnalysisResultWithIssues("ResponsiveTest.java", false, issues, recommendations)]
    }

    private List<AnalysisResult> createEncodingTestResults() {
        def specialIssue = createConcurrencyIssue("ENCODING_TEST", IssueSeverity.HIGH,
            "Issue with <dangerous> tags & 'quotes' and \"double quotes\" and special chars: àáâãäå")
        
        return [createAnalysisResultWithIssues("EncodingTest.java", false, [specialIssue], [])]
    }

    private AnalysisResult createAnalysisResultWithIssues(String fileName, boolean threadSafe,
                                                         List<ConcurrencyIssue> issues,
                                                         List<ConcurrencyRecommendation> recommendations) {
        def result = new AnalysisResult()
        result.filePath = Paths.get(fileName)
        result.analyzedClasses = 1
        result.threadSafe = threadSafe
        result.hasErrors = false
        result.issues = issues ?: []
        result.recommendations = recommendations ?: []
        return result
    }

    private ConcurrencyIssue createConcurrencyIssue(String type, IssueSeverity severity, String description) {
        def issue = new ConcurrencyIssue()
        issue.type = type
        issue.severity = severity
        issue.className = "TestClass"
        issue.lineNumber = 42
        issue.description = description
        return issue
    }

    private ConcurrencyRecommendation createDetailedRecommendation(String description,
                                                                  RecommendationPriority priority,
                                                                  RecommendationEffort effort) {
        def rec = new ConcurrencyRecommendation()
        rec.setDescription(description)
        rec.setPriority(priority)
        rec.setEffort(effort)
        return rec
    }
}
